// Generated by PyCUDA Compiler

// Thread indexing helpers
#define THREAD_ID (blockIdx.x * blockDim.x + threadIdx.x)
#define GRID_STRIDE (blockDim.x * gridDim.x)

struct String {
    char data[64];
    int length;
    
    __device__ String() : length(0) { data[0] = 0; }
    
    __device__ String(const char* s) {
        length = 0;
        for(int i=0; i<63 && s[i] != 0; ++i) {
            data[i] = s[i];
            length++;
        }
        data[length] = 0;
    }
    
    __device__ int len() const { return length; }
    
    __device__ bool operator==(const String& other) const {
        if (length != other.length) return false;
        for(int i=0; i<length; ++i) {
            if (data[i] != other.data[i]) return false;
        }
        return true;
    }
};

__global__ void maximum_path_jit(int* paths, int _shape_paths_0, int _stride_paths_0, int _shape_paths_1, int _stride_paths_1, int _shape_paths_2, int _stride_paths_2, float* values, int _shape_values_0, int _stride_values_0, int _shape_values_1, int _stride_values_1, int _shape_values_2, int _stride_values_2, int* t_ys, int _shape_t_ys_0, int _stride_t_ys_0, int* t_xs, int _shape_t_xs_0, int _stride_t_xs_0) {
    int b;
    float max_neg_val;
    int i;
    int* path;
    float* value;
    int t_y;
    int t_x;
    float v_prev;
    float v_cur;
    int index;
    int y;
    int x_start;
    int x_end;
    int x;
    float val_max;
    int should_dec;
    b = _shape_paths_0;
    max_neg_val = (-1000000000.0f);
    for (int i = 0 + THREAD_ID * (1); i < (int)(b); i += GRID_STRIDE * (1)) {
        path = (paths + (i * _stride_paths_0));
        value = (values + (i * _stride_values_0));
        t_y = t_ys[(i * _stride_t_ys_0)];
        t_x = t_xs[(i * _stride_t_xs_0)];
        v_prev = 0.0f;
        v_cur = 0.0f;
        index = (t_x - 1);
        for (int y = 0; y < t_y; y += 1) {
            x_start = (int)(fmaxf(0, ((t_x + y) - t_y)));
            x_end = (int)(fminf(t_x, (y + 1)));
            for (int x = x_start; x < x_end; x += 1) {
                if ((x == y)) {
                    v_cur = max_neg_val;
                } else {
                    v_cur = value[((y - 1) * _stride_values_1) + (x * _stride_values_2)];
                }
                if ((x == 0)) {
                    if ((y == 0)) {
                        v_prev = 0.0f;
                    } else {
                        v_prev = max_neg_val;
                    }
                } else {
                    v_prev = value[((y - 1) * _stride_values_1) + ((x - 1) * _stride_values_2)];
                }
                val_max = v_prev;
                if ((v_cur > v_prev)) {
                    val_max = v_cur;
                }
                value[(y * _stride_values_1) + (x * _stride_values_2)] += val_max;
            }
        }
        y = (t_y - 1);
        while ((y >= 0)) {
            path[(y * _stride_paths_1) + (index * _stride_paths_2)] = 1;
            if ((index != 0)) {
                should_dec = 0;
                if ((index == y)) {
                    should_dec = 1;
                } else {
                    if ((value[((y - 1) * _stride_values_1) + (index * _stride_values_2)] < value[((y - 1) * _stride_values_1) + ((index - 1) * _stride_values_2)])) {
                        should_dec = 1;
                    }
                }
                if ((should_dec == 1)) {
                    index = (index - 1);
                }
            }
            y -= 1;
        }
    }
}
